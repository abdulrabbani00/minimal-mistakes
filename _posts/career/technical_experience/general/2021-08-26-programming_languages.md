---
title: "Programming Languages"
permalink: /categories/career/technical_experience/programming_languages
layout: single
author_profile: false
categories:
  - technical_experience
sidebar:
  nav: "technical_experience"
tag:
  - technical_experience
  - devops
  - tech
  - personal
  - python
  - C++
  - C
header:
  overlay_image: "/assets/images/categories/career/technical_experience/general/programming_languages_1.jpg"
  teaser: "/assets/images/categories/career/technical_experience/general/programming_languages_1.jpg"
---

# Overview

Throughout my career, I have had the opportunity to program in several languages and support applications written in those languages. Both roles have helped me understand application development more deeply. As a developer, you focus on functionality and capability; as support, you focus on performance and deliverability.

Having insight into both roles helped me understand that code should not only be written to solve the problem but to fit in harmoniously with technical infrastructure. While some developers code in a vacuum and some operational engineers focus solely on execution, the end goal should be for both sides to be mindful of one and other and to work together. For any technical infrastructure to be mature, Dev and Ops must come together.

In this post, I explain my understanding of some of my favorite programming languages, and my experience with them from both sides.

# Python

Python holds a special place in my heart as its the first programming language I learned. I learned Python by watching videos from [Corey Shafer](https://www.youtube.com/c/Coreyms), reading Dan Bader's book, [Python Tricks](https://realpython.com/products/python-tricks-book/), and, most importantly, writing a lot of code. I also learned programming fundamentals in Python and relearned how to write clean code in Python.

**I have worked with** _**Python**_ **in the following capacity:**

- I have used Python to write code in production. Some of the libraries I leveraged were Pandas, NumPy, JSON, Requests, and Logging.

- I have used Python for ETL, data engineering, monitoring, general scripting, automation, releases, and many other ways.

**I know** _**Python**_ **to the following level:**

- I understand the core fundamentals of Python and utilize them for writing simple, clean, and efficient code.

- I can easily express my ideas in Python without referring to external resources (AKA Google).

**This is how I would like to continue my growth and understanding of** _**Python:**_

- I love to write a library in C and utilize it in my Python code.

- I would love to contribute to an open-source library like Pandas or Request.

# C++

Although Python was the first language I learned to program in, applications written in C++ were the first that I ever supported. I was exposed to C++ as an SRE, and I learned to configure the application for maximum performance and minimal latency. After learning Python, I spent many months [learning C++](https://www.youtube.com/c/TheChernoProject), and after a long road, I can proudly say I can comfortably write code in C++.

Learning C++ as a developer and an operation engineer really opened my eyes to the intricacies and depth of application development. I was exposed to so many new concepts, both from a programmatic perspective and from a functional perspective.

**I have worked with** _**C++**_ **in the following capacity:**

- I have supported, configured, monitored, deployed, optimized, and tested low-latency trading applications written in C++.

- I have written C++ code in a controlled environment to ensure I understand its core fundamentals and vast features.

**I know** _**C++**_ **to the following level:**

- I understand the dependencies, features, components, and use cases of C++.

- I can write code in C++, leverage a make file for compilation, and test my application for efficiency and performance.

**This is how I would like to continue my growth and understanding of** _**C++:**_

- I would love the opportunity to write C++ code in production.

- I would like to utilize popular C++ libraries in my code (STL, POCO, Boost, etc).

# C

I often find people categorizing C++ and C but only talking about C++. C deserves its own recognition. In fact, I prefer C over C++. I often find myself (and others) writing unnecessarily complex code in C++ that can be written more simply by leveraging C.

After learning C++, I decided to learn C thinking it would “be the same thing.” I was pleasantly surprised when it wasn’t. I thoroughly enjoy the design of C and its implementation, and I wish more people wrote C code in C++ and only used objects and templates where needed.

C’s simplicity is what makes it stand out to me and millions of other developers. It is no surprise that this easy-to-use language was utilized to build the world's most powerful operating system.

**I have worked with** _**C**_ **in the following capacity:**

- I have spent many hours reading Linux Kernel Code in C and tinkering with it. By playing around with the kernel, I was able to learn more about Linux and C together (two things that I love).

- I have written C code in a controlled environment to ensure I understand its core fundamentals and vast features.

- I learned coding best practices when learning C, and I learned to write clean, simple code because of it.

**I know** _**C**_ **to the following level:**

- I understand the ideologies and best practices of C and learned to keep my code simple in other languages because of it.

- I can write code in C, leverage a make file for compilation, and test my application for efficiency and performance.

**This is how I would like to continue my growth and understanding of** _**C:**_

- It is a career goal of mine to contribute _meaningful_ code to the Linux Kernel.

- I would love to write a library in C and utilize it in Python.

- I would like the opportunity to write production-level applications in C.

# Go

As someone who enjoys the complexity of low-level applications and languages, yet likes the simple syntax of high-level languages, Go was a must-learn. Through books and simple practice, I have been learning Go and learning the best practices of the language.

I have contributed open-source code in the blockchain space using Golang. There are lots of features and concepts within Go that I am a fan of.

**I have worked with** _**Go**_ **in the following capacity:**

- I have provided organizational-level value by writing applications in Go from scratch, testing, deploying, monitoring, and maintaining them.

- I have worked on various open-source repositories within the blockchain space, such as a fork of go-ethereum, and provided core contributions.

- I have utilized applications in Go, such as Terraform, and understand them deeply. This understanding gives me some insight into the capabilities and functionalities of Go.

**I know** _**Go**_ **to the following level:**

- I understand the best practices within Go, as well as the general concepts within the language.

- I understand when to use specific Go features to conform to best practices and maximize efficiency.

- I understand how to write clean, efficient code, test it, compile it, and deploy it.

**This is how I would like to continue my growth and understanding of** _**Go:**_

- I want to continue providing value in the blockchain and open-source space by writing code in Golang.

# Scala

I decided to learn Scala due to my interest in data engineering. Many popular data engineering tools are built in, or leverage Scala, such as **Apache Spark**. One of the main reasons that I am not the biggest fan of Java is that it's been primarily used as an Object-Oriented **only** programming language. While I like OOP, I don’t think it captures every use case.

I was drawn to Scala because it has both OOP and functional programming. Scala is the first functional programming language that I have learned, as well as the first language I have programmed in that leverages the JVM.

I have enjoyed learning functional programming concepts and ideologies. I hope to write code in Scala throughout my career.

**I have worked with** _**Scala**_ **in the following capacity:**

- I have leveraged both OOP and functional programming in Scala.

- I have utilized SBT for package management, configuration, and runtime.

- I have written code in Scala to grasp all of its built-in features.

**I know** _**Scala**_ **to the following level:**

- I understand best practices as they relate to functional programming within Scala.

- I understand how to integrate OOP and functional programming to get the best of both worlds.

- I understand how to write clean, efficient code, test it, compile it, and deploy it.

**This is how I would like to continue my growth and understanding of** _**Scala:**_

- I would love to write production code for a data pipeline using Scala.

- I would like to familiarize myself with popular Scala frameworks and libraries.

# Bash

Good old Bash, thank you for saving us all countless hours. Although it is not considered a programming language, Bash has saved programmers lots of time. I have used Bash in many ways, and I am grateful for its existence.

**I have worked with** _**Bash**_ **in the following capacity:**

- I have written hundreds of scripts in Bash for basic tasks, validation, and deployment.

- I have worked with complex Bash scripts written internally and by the open-source community.

**I know** _**Bash**_ **to the following level:**

- I can write Bash code with relative ease (I still need Google).

- I am aware of hidden features and certain gotcha’s.

**This is how I would like to continue my growth and understanding of** _**Bash:**_

- I simply want to keep using this powerful tool to make my life easier.

# Lua

Lua is a gem hidden deep within the glorious application known as NGINX and sometimes goes unnoticed. I have utilized Lua to write powerful extensions within NGINX and custom functionality where needed. As someone who has spent many years working with NGINX, I wish Lua got more attention. Lua is a robust programming language with a direct integration to NGINX that could help a lot of DevOps engineers.

**I have worked with** _**Lua**_ **in the following capacity:**

- I have written a few Lua scripts to add custom functionality within NGINX.

**I know** _**Lua**_ **to the following level:**

- I know the basic features of LUA and process the knowledge to use those basic features to make NGINX more robust.

**This is how I would like to continue my growth and understanding of** _**Lua:**_

- Like Bash, I simply want to keep using this powerful language to make my life easier.
